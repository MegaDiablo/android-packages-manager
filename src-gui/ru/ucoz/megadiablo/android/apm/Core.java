package ru.ucoz.megadiablo.android.apm;import java.io.File;import java.util.ArrayList;import java.util.List;import javax.swing.JOptionPane;import javax.swing.SwingUtilities;import ru.ucoz.megadiablo.android.apm.connect.ListConnect;import ru.ucoz.megadiablo.android.apm.iface.DevicesListener;import ru.ucoz.megadiablo.android.apm.iface.PackagesListener;import ru.ucoz.megadiablo.android.apm.ui.plaf.Theme;import ru.ucoz.megadiablo.android.apm.ui.settings.Settings;import ru.ucoz.megadiablo.android.apm.ui.shell.Shell;import com.adbhelper.adb.AdbDevice;import com.adbhelper.adb.AdbModule;import com.adbhelper.adb.AdbPackage;import com.adbhelper.adb.ILogListener;import com.adbhelper.adb.exceptions.AdbException;import com.adbhelper.adb.exceptions.DeviceNotAvailableException;import com.adbhelper.adb.exceptions.NotFoundActivityException;import com.adbhelper.adb.exceptions.install.InstallException;import com.adbhelper.adb.exceptions.install.InstallExceptionAlreadyExists;import com.adbhelper.adb.exceptions.install.InstallExceptionInconsistrentCertificates;import com.adbhelper.adb.exceptions.install.InstallExceptionInvalidInstallLocation;import com.adbhelper.adb.exceptions.install.InstallExceptionNotFoundFile;import com.adbhelper.adb.shell.AdbShell;/** * @author MegaDiablo * */public class Core {	private static final String ERROR_MESSAGE_INSTALL =			"Приложение не может быть установленно.\n%s";	private Events mEvents;	private Settings mSettings;	private ListConnect mListConnect;	private AdbModule mAdbModule;	private AdbDevice mSelectDevice = null;	private List<DevicesListener> mDevicesListeners =			new ArrayList<DevicesListener>();	private List<PackagesListener> mPackagesListeners =			new ArrayList<PackagesListener>();	public Core(final AdbModule pAdbModule, final Events pEvents) {		mAdbModule = pAdbModule;		mEvents = pEvents;		mSettings = Settings.getInstance();		mListConnect = new ListConnect(this);	}	public AdbDevice getSelectDevice() {		return mSelectDevice;	}	public void setSelectDevice(final AdbDevice pAdbDevice) {		String name = "Выбор устройства";		String desc = String.format("Смена устройства на %s.", pAdbDevice);		mEvents.add(EnumEvents.SELECT_DEVICE, name, desc, new Runnable() {			@Override			public void run() {				if (mSelectDevice == null && mSelectDevice != pAdbDevice						|| mSelectDevice != null						&& !mSelectDevice.equals(pAdbDevice)) {					mSelectDevice = pAdbDevice;					fireListener(							mDevicesListeners,							new EventListener<DevicesListener>() {								@Override								public void perfom(final DevicesListener pItem) {									pItem.changeSelectDevice(pAdbDevice);								}							});					refreshPackages();				}			}		});	}	public void refreshDevices() {		String name = "Обновление списка устройств";		String desc = "Обновления списка подключенных устройств.";		mEvents.add(EnumEvents.REFRESH_DEVICES, name, desc, new Runnable() {			@Override			public void run() {				final List<AdbDevice> devices = mAdbModule.devices();				fireListener(						mDevicesListeners,						new EventListener<DevicesListener>() {							@Override							public void perfom(final DevicesListener pItem) {								pItem.updateListDevices(devices);							}						});				if (!devices.contains(mSelectDevice)) {					final AdbDevice device = mSelectDevice;					if (mSelectDevice != null) {						fireListener(								mDevicesListeners,								new EventListener<DevicesListener>() {									@Override									public void perfom(final DevicesListener pItem) {										pItem.lostSelectDevice(device);									}								});					}					if (devices.size() > 0) {						setSelectDevice(devices.get(0));					} else {						setSelectDevice(null);					}				}			}		},				false);	}	public void refreshPackages() {		String name = "Обновление списка пакетов";		String desc =				"Обновляется список пакетов на текущем выделеннойм утсройстве.";		mEvents.add(EnumEvents.REFRESH_PACKAGES, name, desc, new Runnable() {			@Override			public void run() {				List<AdbPackage> packs = new ArrayList<AdbPackage>();				if (mSelectDevice == null) {					packs = new ArrayList<AdbPackage>();				} else {					try {						packs =								mSelectDevice.refreshListPackages(mSettings										.isVisibleSystemPackages());					} catch (AdbException e) {						e.printStackTrace();					}				}				final List<AdbPackage> packages = packs;				fireListener(						mPackagesListeners,						new EventListener<PackagesListener>() {							@Override							public void perfom(final PackagesListener pItem) {								pItem.updatePackages(packages);							}						});			}		},				false);	}	public void rebootDevice() {		String name = "Перезагрузка";		String desc =				String.format("Перезагрузка устройства %s.", mSelectDevice);		mEvents.add(EnumEvents.REBOOT_DEVICE, name, desc, new Runnable() {			@Override			public void run() {				if (mSelectDevice != null) {					try {						mSelectDevice.reboot();					} catch (AdbException e) {						e.printStackTrace();					}					refreshDevices();				}			}		});	}	public void runShell() {		String name = "Консоль";		String desc =				String.format("Консоль для устройства %s.", mSelectDevice);		mEvents.add(EnumEvents.SHELL, name, desc, new Runnable() {			@Override			public void run() {				if (mSelectDevice != null) {					AdbShell adbShell = mSelectDevice.createShell();					createShellWindow(adbShell);				}			}		});	}	public void runShellRunAs(final AdbPackage pAdbPackage) {		String name = "Консоль приложения";		String desc =				String.format("Консоль с правми приложения %s.", pAdbPackage);		mEvents.add(EnumEvents.RUN_AS, name, desc, new Runnable() {			@Override			public void run() {					AdbShell adbShell = pAdbPackage.createShellRunAs();					createShellWindow(adbShell);			}		});	}	protected void createShellWindow(final AdbShell pAdbShell) {		SwingUtilities.invokeLater(new Runnable() {			@Override			public void run() {				Shell shell = new Shell(pAdbShell);				shell.setVisible(true);			}		});	}	public void install(final String pFile) {		String name = "Установка приложения";		String desc = String.format("Установка приложение %s.", pFile);		mEvents.add(EnumEvents.INSTALL, name, desc, new Runnable() {			@Override			public void run() {				try {					if (mSettings.isUseReinstall()) {						mSelectDevice.reinstall(								pFile,								mSettings.isAutostartPackage());					} else {						mSelectDevice.install(								pFile,								mSettings.isAutostartPackage());					}				} catch (InstallExceptionAlreadyExists e) {					String text =							String.format(									ERROR_MESSAGE_INSTALL,									"Приложение уже установлено.");					showErrorDialog(text);				} catch (InstallExceptionNotFoundFile e) {					String text =							String.format(									ERROR_MESSAGE_INSTALL,									"Файл не найден.");					showErrorDialog(text);				} catch (InstallExceptionInconsistrentCertificates e) {					String text =							String.format(									ERROR_MESSAGE_INSTALL,									"Несоответствие сертификатов. \nНеобходимо удалить предыдущую версию приложения(пакета).");					showErrorDialog(text);				} catch (InstallExceptionInvalidInstallLocation e) {					String text =							String.format(									ERROR_MESSAGE_INSTALL,									"Пакет не может быть установлен в указанное место.");					showErrorDialog(text);				} catch (InstallException e) {					String text =							String.format(ERROR_MESSAGE_INSTALL, e.getMessage());					showErrorDialog(text);					e.printStackTrace();				} catch (AdbException e) {					String text =							String.format(ERROR_MESSAGE_INSTALL, e.getMessage());					showErrorDialog(text);					e.printStackTrace();				}			}		});	}	public void install(final File... pFile) {		for (File file : pFile) {			install(file.getAbsolutePath());		}		refreshPackages();	}	public void uninstall(final AdbPackage pAdbPackage) {		String name = "Удаление приложения";		String desc = String.format("Удаляется приложение %s.", pAdbPackage);		mEvents.add(EnumEvents.UNINSTALL, name, desc, new Runnable() {			@Override			public void run() {				try {					pAdbPackage.uninstall();				} catch (DeviceNotAvailableException e) {					e.printStackTrace();				}			}		});	}	public void download(final AdbPackage pAdbPackage, final String pPath) {		String name = "Скачка приложения";		String desc = String.format("Скачивает приложение %s.", pAdbPackage);		mEvents.add(EnumEvents.DOWNLOAD, name, desc, new Runnable() {			@Override			public void run() {				try {					if (pPath == null) {						pAdbPackage.download();					} else {						pAdbPackage.download(pPath);					}				} catch (DeviceNotAvailableException e) {					e.printStackTrace();				}			}		});	}	public void startApp(final AdbPackage pAdbPackage, final boolean pDebug) {		String name = "Запуск приложения";		String desc = String.format("Запускает приложение %s.", pAdbPackage);		mEvents.add(EnumEvents.START_APPLICATION, name, desc, new Runnable() {			@Override			public void run() {				try {					if (pDebug) {						pAdbPackage.debug();					} else {						pAdbPackage.start();					}				} catch (NotFoundActivityException e) {					e.printStackTrace();				} catch (DeviceNotAvailableException e) {					e.printStackTrace();				}			}		});	}	public void monkeyApp(final AdbPackage pAdbPackage, final int pCount) {		String name = "Запуск Monkey";		String desc = String.format("Запускает monkey для приложения %s.", pAdbPackage);		mEvents.add(EnumEvents.MONKEY, name, desc, new Runnable() {			@Override			public void run() {				try {					pAdbPackage.monkey(pCount);				} catch (DeviceNotAvailableException e) {					e.printStackTrace();				}			}		});	}	public void clearDataApp(final AdbPackage pAdbPackage) {		String name = "Очистка данных приложения";		String desc = String.format("Очищает данные приложения %s.", pAdbPackage);		mEvents.add(EnumEvents.CLEAR_DATA, name, desc, new Runnable() {			@Override			public void run() {				try {					pAdbPackage.clearData();				} catch (DeviceNotAvailableException e) {					e.printStackTrace();				}			}		});	}	public void updateInforamtionApplication(final AdbPackage pAdbPackage) {		String name = "Получение информации";		String desc =				String.format(						"Получение информации о приложении %s.",						pAdbPackage);		mEvents.add(EnumEvents.START_APPLICATION, name, desc, new Runnable() {			@Override			public void run() {				try {					pAdbPackage.update();				} catch (DeviceNotAvailableException e) {					e.printStackTrace();				}			}		});	}	public void sendKey(final int pKey) {		String name = "Нажать клавишу";		String desc = String.format("Нажать клавишу с кодом %s.", pKey);		mEvents.add(EnumEvents.SEND_KEY, name, desc, new Runnable() {			@Override			public void run() {				try {					mSelectDevice.sendKeyCode(pKey);				} catch (DeviceNotAvailableException e) {					e.printStackTrace();				}			}		});	}	public void termantedAllTasks() {		mEvents.clearList();		terminatedCurrentTask();	}	public void terminatedCurrentTask() {		mAdbModule.stopCurrentProcess();	}	public void stopAdb() {		String name = "Остановка ADB";		String desc = "Останавливается ADB";		mEvents.add(EnumEvents.STOP_ADB, name, desc, new Runnable() {			@Override			public void run() {				mAdbModule.stop();				mSelectDevice = null;				refreshEmptyDevices();				refreshEmptyPackages();			}		});	}	public void startAdb() {		String name = "Запуск ADB";		String desc = "Запускается ADB";		mEvents.add(EnumEvents.START_ADB, name, desc, new Runnable() {			@Override			public void run() {				mAdbModule.start();				refreshDevices();				refreshPackages();			}		});	}	public void restartAdb() {		String name = "Перезапуск ADB";		String desc = "Перезапускается ADB";		mEvents.add(EnumEvents.RESTART_ADB, name, desc, new Runnable() {			@Override			public void run() {				mAdbModule.restart();				mSelectDevice = null;				refreshDevices();				// refreshPackages();			}		});	}	public void clearFolderTemp() {		String name = "Очистка папки";		String desc =				String.format(						"Очистка папки '%s' на устройстве %s.",						"temp",						mSelectDevice);		mEvents.add(EnumEvents.CLEAR_FOLDER_TEMP, name, desc, new Runnable() {			@Override			public void run() {				if (mSelectDevice != null) {					try {						mSelectDevice.clearTemp();					} catch (DeviceNotAvailableException e) {						e.printStackTrace();					}				}			}		});	}	public void connectNetworkDevice(final String pConnect) {		String name = "Подключить устройство";		String desc =				String.format("Подключает сетевое устройство %s", pConnect);		mEvents.add(				EnumEvents.CONNECT_NETWORK_DEVICE,				name,				desc,				new Runnable() {					@Override					public void run() {						mAdbModule.connet(pConnect);					}				});	}	public ListConnect getListConnects() {		return mListConnect;	}	public void setLookAndFeel(final Theme pTheme) {		if (pTheme == null) {			mSettings.removeLookAndFeel();		} else {			mSettings.setLookAndFeel(pTheme.getKey());		}	}	// ====================================================	// Private methods/interfaces	// ====================================================	// ====================================================	// Devices listener	// ====================================================	public void addDevicesListener(final DevicesListener pDevicesListener) {		addListener(mDevicesListeners, pDevicesListener);	}	public void removeDevicesListener(final DevicesListener pDevicesListener) {		removeListener(mDevicesListeners, pDevicesListener);	}	public void removeAllDevicesListener() {		removeAllListener(mDevicesListeners);	}	// ====================================================	// Packages listener	// ====================================================	public void addPackagesListener(final PackagesListener pListener) {		addListener(mPackagesListeners, pListener);	}	public void removePackagesListener(final PackagesListener pListener) {		removeListener(mPackagesListeners, pListener);	}	public void removeAllPackagesListener() {		removeAllListener(mPackagesListeners);	}	// ====================================================	// private methods/interface listeners	// ====================================================	private <T> void addListener(final List<T> pList, final T pItem) {		if (pList != null && pItem != null) {			pList.add(pItem);		}	}	private <T> void removeListener(final List<T> pList, final T pItem) {		if (pList != null && pItem != null) {			pList.remove(pItem);		}	}	private <T> void removeAllListener(final List<T> pList) {		pList.clear();	}	private <T> void fireListener(final List<T> pList,			final EventListener<T> pEvent) {		if (pList == null) {			return;		}		for (T item : pList) {			if (item != null) {				pEvent.perfom(item);			}		}	}	private void refreshEmptyPackages() {		final List<AdbPackage> packages = new ArrayList<AdbPackage>();		fireListener(mPackagesListeners, new EventListener<PackagesListener>() {			@Override			public void perfom(final PackagesListener pItem) {				pItem.updatePackages(packages);			}		});	}	private void refreshEmptyDevices() {		final List<AdbDevice> devices = new ArrayList<AdbDevice>();		fireListener(mDevicesListeners, new EventListener<DevicesListener>() {			@Override			public void perfom(final DevicesListener pItem) {				pItem.updateListDevices(devices);			}		});	}	private interface EventListener<T> {		void perfom(final T pItem);	}	private void showErrorDialog(final String pText) {		SwingUtilities.invokeLater(new Runnable() {			@Override			public void run() {				JOptionPane.showMessageDialog(						null,						pText,						"Ошибка",						JOptionPane.ERROR_MESSAGE);			}		});	}	public void setLogListener(final ILogListener pLogListener) {		mAdbModule.setLogListener(pLogListener);	}}